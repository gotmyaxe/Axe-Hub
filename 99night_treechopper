-- Axe Hub | Final Integrated Script (Fixed)
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "Axe Hub | 99 Nights In The Forest",
    LoadingTitle = "Axe Hub",
    LoadingSubtitle = "Axe Hub",
    ConfigurationSaving = { Enabled = true, FolderName = "axehub", FileName = "99nights" },
    Discord = { Enabled = false, Invite = "green-eye", RememberJoins = true },
    KeySystem = false,
    ShowText = "Axe Hub ü™ì"
})

local FarmTab   = Window:CreateTab("Farm",      4483362458)
local CollectTab= Window:CreateTab("Collect",   4483362463)
local CombatTab = Window:CreateTab("Combat",    4483362464)
local TeleTab   = Window:CreateTab("Teleport",  4483362465)

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer

local function currentCamera() return workspace.CurrentCamera end

-- state
local autoFarmEnabled   = false
local autoCollectEnabled= false
local killAuraEnabled   = false
local pointerShown      = false

local farmRunning, collectRunning, killRunning, pointerRunning = false, false, false, false

-- defaults/tunables
local swingDelay       = 0.05
local treeSearchRadius = 200
local logSearchRadius  = math.huge
local dragDuration     = 2.0
local dragRetries      = 3
local storeWaitTimeout = 12
local clickSpamDelay   = 0.03

local killRange        = 30
local killCooldown     = 0.09
local killMaxTargets   = 5

-- helpers
local function notify(t,c,d) Rayfield:Notify({ Title = t, Content = c, Duration = d or 2 }) end

local function getCharacterParts()
    local char = player.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    return char, humanoid, hrp
end

player.CharacterAdded:Connect(function() task.wait(0.25) end)

local function equipTool(toolName)
    local char, humanoid = getCharacterParts()
    if not char or not humanoid then return false end
    local tool = char:FindFirstChild(toolName) or player.Backpack:FindFirstChild(toolName)
    if tool then
        pcall(function() humanoid:EquipTool(tool) end)
        task.wait(0.22)
        return true
    end
    return false
end

local function equipBestWeapon()
    local char, humanoid = getCharacterParts()
    if not char or not humanoid then return nil end
    local candidates = {}
    for _,v in ipairs(char:GetChildren()) do if v:IsA("Tool") then table.insert(candidates, v) end end
    for _,v in ipairs(player.Backpack:GetChildren()) do if v:IsA("Tool") then table.insert(candidates, v) end end
    if #candidates == 0 then return nil end
    local function score(tool)
        local nm = tostring(tool.Name):lower()
        local s = 0
        if tool:FindFirstChild("MeleeServer") then s = s + 50 end
        if nm:find("axe") then s = s + 40 end
        if nm:find("sword") or nm:find("blade") then s = s + 35 end
        if nm:find("old") then s = s + 5 end
        return s
    end
    table.sort(candidates, function(a,b) return score(a) > score(b) end)
    local best = candidates[1]
    pcall(function() humanoid:EquipTool(best) end)
    task.wait(0.18)
    return best
end

local function clickAt(x,y,times,delay)
    times = times or 1
    delay = delay or 0.03
    for i=1,times do
        pcall(function()
            VirtualInputManager:SendMouseButtonEvent(x,y,0,true,game,0)
            VirtualInputManager:SendMouseButtonEvent(x,y,0,false,game,0)
        end)
        task.wait(delay)
    end
end

local function centerClick(times,delay)
    local cam = currentCamera()
    if not cam then return end
    local vs = cam.ViewportSize
    clickAt(vs.X/2, vs.Y/2, times or 1, delay or 0.03)
end

local function moveTo(position, speedDiv)
    local _,_,hrp = getCharacterParts()
    if not hrp then return end
    speedDiv = (speedDiv and speedDiv > 0) and speedDiv or 16
    local dist = (hrp.Position - position).Magnitude
    local duration = math.max(dist / speedDiv, 0.05)
    local tween = TweenService:Create(hrp, TweenInfo.new(duration, Enum.EasingStyle.Linear), {CFrame = CFrame.new(position)})
    tween:Play()
    local completed = false
    local connection = tween.Completed:Connect(function() completed = true end)
    -- Wait with timeout to prevent infinite waiting
    local startTime = tick()
    while not completed and (tick() - startTime) < (duration + 2) do
        task.wait(0.1)
    end
    connection:Disconnect()
end

local function faceCameraTo(point)
    local cam = currentCamera()
    if not cam then return end
    local camPos = cam.CFrame.Position
    pcall(function() cam.CFrame = CFrame.new(camPos, point) end)
    task.wait(0.02)
end

-- ===== Trees (Auto Chop) =====
local function isBigQuestTree(model)
    if not model then return false end
    local name = tostring(model.Name):lower()
    if name:find("big") or name:find("quest") or name:find("fire") then return true end
    local trunk = model:FindFirstChild("Trunk") or model:FindFirstChildWhichIsA("BasePart")
    if trunk and trunk.Size and trunk.Size.Y and trunk.Size.Y > 60 then return true end
    return false
end

local function getNearestTree()
    local _,_,hrp = getCharacterParts()
    if not hrp then return nil end
    local rootPos = hrp.Position
    local nearest, nd = nil, math.huge
    local function checkFolder(folder)
        for _,obj in ipairs(folder:GetChildren()) do
            if obj:IsA("Model") and obj:FindFirstChild("Trunk") and not isBigQuestTree(obj) then
                local part = obj:FindFirstChild("Trunk") or obj:FindFirstChildWhichIsA("BasePart")
                if part then
                    local d = (rootPos - part.Position).Magnitude
                    if d < nd and d <= treeSearchRadius then nd, nearest = d, obj end
                end
            end
        end
    end
    if workspace:FindFirstChild("Map") then
        if workspace.Map:FindFirstChild("Landmarks") then checkFolder(workspace.Map.Landmarks) end
        if workspace.Map:FindFirstChild("Foliage") then checkFolder(workspace.Map.Foliage) end
    end
    return nearest
end

local function swingForTree(tree)
    local char = player.Character
    if not char then return end
    local tool = char:FindFirstChildWhichIsA("Tool")
    if tool and tool:FindFirstChild("MeleeServer") then
        if tree and tree:FindFirstChild("Humanoid") then
            pcall(function() tool.MeleeServer.Hit:InvokeServer(tree:FindFirstChild("Humanoid")) end)
        else
            centerClick(1,0)
        end
    else
        pcall(function()
            if tool and tool.Activate then
                tool:Activate()
            else
                centerClick(1,0)
            end
        end)
    end
end

local function chopLoopFor(tree)
    if not tree or not tree.Parent then return end
    equipTool("Old Axe")
    local trunk = tree:FindFirstChild("Trunk") or tree:FindFirstChildWhichIsA("BasePart")
    if not trunk then return end
    local targetPos = trunk.Position + Vector3.new(0,0,3)
    moveTo(targetPos)
    while autoFarmEnabled and tree and tree.Parent do
        swingForTree(tree)
        task.wait(math.max(0.001, swingDelay))
    end
end

local function farmWorker()
    if farmRunning then return end
    farmRunning = true
    while autoFarmEnabled do
        local ok, tree = pcall(getNearestTree)
        if ok and tree then
            pcall(chopLoopFor, tree)
        else
            task.wait(0.6)
        end
    end
    farmRunning = false
end

-- ===== Logs (drag + physical move + store) =====
local function isValidLogModel(obj)
    if not obj then return false end
    local nm = tostring(obj.Name):lower()
    if nm:find("fallenlog") or nm:find("fallen_log") or nm:find("fallen") or nm:find("log") or nm:find("wood") then return true end
    return false
end

local function findNearestLogPart()
    local _,_,hrp = getCharacterParts()
    if not hrp then return nil end
    local rootPos = hrp.Position
    local nearestPart, nd = nil, math.huge
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and isValidLogModel(obj) then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if part and not part.Anchored then
                local d = (rootPos - part.Position).Magnitude
                if d < nd and d <= logSearchRadius then nd, nearestPart = d, part end
            end
        elseif obj:IsA("BasePart") then
            local nm = tostring(obj.Name):lower()
            if (nm:find("fallenlog") or nm:find("fallen_log") or nm:find("fallen") or nm:find("log") or nm:find("wood")) and not obj.Anchored then
                local d = (rootPos - obj.Position).Magnitude
                if d < nd and d <= logSearchRadius then nd, nearestPart = d, obj end
            end
        end
    end
    return nearestPart
end

local function scanGuiForStoreButton()
    local function scan(root)
        if not root then return nil end
        for _, obj in ipairs(root:GetDescendants()) do
            if (obj:IsA("TextButton") or obj:IsA("ImageButton")) then
                local nm = tostring(obj.Name):lower()
                local txt = ""
                if obj:IsA("TextButton") or obj:IsA("TextLabel") then txt = tostring(obj.Text or ""):lower() end
                if nm:find("store") or txt:find("store") then
                    if obj.Visible ~= false and obj.AbsoluteSize and obj.AbsoluteSize.Magnitude > 0 then
                        return obj
                    end
                end
            end
        end
        return nil
    end
    local pg = player:FindFirstChildOfClass("PlayerGui")
    local found = scan(pg)
    if found then return found end
    found = scan(CoreGui)
    return found
end

-- pointer overlay
local pointerGui, pointerFrame, pointerConn
local function createPointer()
    if pointerGui and pointerGui.Parent then return end
    pointerGui = Instance.new("ScreenGui")
    pointerGui.Name = "AxeHub_StorePointer"
    pointerGui.ResetOnSpawn = false
    pointerGui.Parent = CoreGui
    pointerFrame = Instance.new("ImageLabel", pointerGui)
    pointerFrame.Size = UDim2.new(0,48,0,48)
    pointerFrame.AnchorPoint = Vector2.new(0.5,0.5)
    pointerFrame.BackgroundTransparency = 1
    local t = Instance.new("TextLabel", pointerFrame)
    t.Size = UDim2.new(1,0,1,0)
    t.BackgroundTransparency = 1
    t.Text = "‚óè"
    t.TextScaled = true
    t.TextColor3 = Color3.new(1,1,1)
end

local function destroyPointer()
    if pointerConn then pointerConn:Disconnect() pointerConn = nil end
    if pointerGui then pcall(function() pointerGui:Destroy() end) pointerGui = nil pointerFrame = nil end
end

local function startPointerLoop()
    if pointerRunning then return end
    pointerRunning = true
    createPointer()
    pointerConn = RunService.RenderStepped:Connect(function()
        if not pointerRunning then return end
        if not pointerShown then
            if pointerFrame then pointerFrame.Visible = false end
            return
        end
        local btn = scanGuiForStoreButton()
        if btn and pointerFrame then
            local pos = btn.AbsolutePosition
            local size = btn.AbsoluteSize
            pointerFrame.Position = UDim2.new(0, pos.X + size.X/2, 0, pos.Y + size.Y/2)
            pointerFrame.Visible = true
        else
            if pointerFrame then pointerFrame.Visible = false end
        end
    end)
end

local function stopPointerLoop()
    pointerRunning = false
    destroyPointer()
end

-- drag helpers (mouse simulation)
local function dragMouse(startX,startY,targetX,targetY,steps, stepDelay)
    steps = steps or 8
    stepDelay = stepDelay or 0.03
    pcall(function() VirtualInputManager:SendMouseButtonEvent(startX,startY,0,true,game,0) end)
    task.wait(0.03)
    for i=1,steps do
        local t = i/steps
        local nx = startX + (targetX - startX) * t
        local ny = startY + (targetY - startY) * t
        pcall(function() VirtualInputManager:SendMouseButtonEvent(nx,ny,0,true,game,0) end)
        task.wait(stepDelay)
    end
end

local function releaseMouseAt(x,y)
    pcall(function() VirtualInputManager:SendMouseButtonEvent(x,y,0,false,game,0) end)
end

-- try to physically move log model toward player (if unanchored)
local function nudgeLogTowards(logPart, targetWorldPos, strength)
    pcall(function()
        local model = nil
        if logPart and logPart:IsA("BasePart") and logPart.Parent then
            if logPart.Parent:IsA("Model") then model = logPart.Parent end
        end
        if model then
            local primary = model.PrimaryPart or logPart
            if primary and not primary.Anchored then
                local offset = (targetWorldPos - primary.Position) * math.clamp(strength or 0.5, 0, 1)
                for _, part in ipairs(model:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored then
                        part.CFrame = part.CFrame + offset
                    end
                end
            end
        end
    end)
end

-- drag log into store area and wait for store action
local function dragLogThenWaitForStore(logPart)
    if not logPart or not logPart.Parent then return false end
    local cam = currentCamera()
    if not cam then return false end
    local aimPos = logPart.Position + Vector3.new(0, (logPart.Size and logPart.Size.Y or 1)*0.5, 0)
    local screenPos, onScreen = cam:WorldToViewportPoint(aimPos)
    if not onScreen then
        faceCameraTo(aimPos)
        task.wait(0.03)
        screenPos, onScreen = cam:WorldToViewportPoint(aimPos)
        if not onScreen then return false end
    end
    local startX, startY = screenPos.X, screenPos.Y
    local vs = cam.ViewportSize
    local targetX = math.clamp(vs.X * 0.78, 1, vs.X - 2)
    local targetY = math.clamp(vs.Y * 0.78, 1, vs.Y - 2)

    -- attempt both physical nudge and mouse drag for duration
    local steps = math.max(4, math.floor(dragDuration / 0.03))
    local nudgeStrength = 0.5
    local hrp = getCharacterParts() and select(3, getCharacterParts())
    local nudgeTarget = hrp and hrp.Position + Vector3.new(0,0,2) or logPart.Position
    
    -- Start drag
    pcall(function() VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, true, game, 0) end)
    
    for i=1, steps do
        -- nudge model toward camera-target point (server may not accept but we try)
        nudgeLogTowards(logPart, nudgeTarget, nudgeStrength)
        -- partial drag movement
        local t = i/steps
        local nx = startX + (targetX - startX) * t
        local ny = startY + (targetY - startY) * t
        pcall(function() VirtualInputManager:SendMouseButtonEvent(nx, ny, 0, true, game, 0) end)
        task.wait(0.03)
    end
    -- release
    pcall(function() VirtualInputManager:SendMouseButtonEvent(targetX, targetY, 0, false, game, 0) end)
    task.wait(0.06)

    -- notification to user to press store if needed
    notify("Store it!", "Dragged the log ‚Äî click STORE to finish (automated clicks will try too).", 2)

    -- automated attempt to click store button repeatedly while waiting for store removal
    local t0 = tick()
    while logPart and logPart.Parent and tick() - t0 < storeWaitTimeout do
        local storeBtn = scanGuiForStoreButton()
        if storeBtn and storeBtn.AbsolutePosition and storeBtn.AbsoluteSize then
            local sx = storeBtn.AbsolutePosition.X + storeBtn.AbsoluteSize.X/2
            local sy = storeBtn.AbsolutePosition.Y + storeBtn.AbsoluteSize.Y/2
            clickAt(sx, sy, 6, clickSpamDelay)
            -- also click near target release area to ensure interaction
            clickAt(targetX, targetY, 3, clickSpamDelay)
        else
            -- spam at release area
            clickAt(targetX, targetY, 4, clickSpamDelay)
        end
        task.wait(0.2)
    end

    return not (logPart and logPart.Parent)
end

local function collectWorker()
    if collectRunning then return end
    collectRunning = true
    while autoCollectEnabled do
        pcall(function()
            equipTool("Old Sack")
            task.wait(0.08)
            local logPart = findNearestLogPart()
            if logPart then
                moveTo(logPart.Position + Vector3.new(0,0,2), 20)
                task.wait(0.06)
                faceCameraTo(logPart.Position)
                task.wait(0.03)
                local stored = false
                for attempt = 1, dragRetries do
                    if not autoCollectEnabled then break end
                    stored = dragLogThenWaitForStore(logPart)
                    if stored then break end
                    task.wait(0.12)
                end
                task.wait(0.12)
            else
                task.wait(0.25)
            end
        end)
    end
    collectRunning = false
end

-- ===== Kill Aura (animals) =====
local animalsList = { "rabbit", "wolf", "alpha wolf", "alpha_wolf", "alphawolf", "bear" }
local function isAnimalModel(model)
    if not model or not model:IsA("Model") then return false end
    if not model:FindFirstChildWhichIsA("Humanoid") or not model:FindFirstChild("HumanoidRootPart") then return false end
    local nm = tostring(model.Name):lower()
    for _,a in ipairs(animalsList) do
        if nm:find(a) then return true end
    end
    return false
end

local function getNearbyAnimals(range)
    local _,_,hrp = getCharacterParts()
    if not hrp then return {} end
    local res = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if isAnimalModel(obj) then
            local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                local d = (hrp.Position - part.Position).Magnitude
                if d <= range then
                    local hum = obj:FindFirstChildWhichIsA("Humanoid")
                    if hum and hum.Health > 0 then
                        table.insert(res, { model = obj, part = part, humanoid = hum, dist = d })
                    end
                end
            end
        end
    end
    table.sort(res, function(a,b) return a.dist < b.dist end)
    return res
end

local function killAuraWorker()
    if killRunning then return end
    killRunning = true
    while killAuraEnabled do
        local char, humanoid, hrp = getCharacterParts()
        if not hrp then task.wait(0.5) goto CONT end
        local targets = getNearbyAnimals(killRange)
        if #targets > 0 then
            local tool = equipBestWeapon() or (char and char:FindFirstChildWhichIsA("Tool"))
            for i=1, math.min(#targets, killMaxTargets) do
                if not killAuraEnabled then break end
                local t = targets[i]
                if not t or not t.model or not t.humanoid or t.humanoid.Health <= 0 then goto NEXT end
                if tool and tool:FindFirstChild("MeleeServer") then
                    pcall(function() tool.MeleeServer.Hit:InvokeServer(t.humanoid) end)
                else
                    pcall(function()
                        faceCameraTo(t.part.Position)
                        if tool and tool.Activate then
                            tool:Activate()
                        else
                            centerClick(1,0)
                        end
                    end)
                end
                task.wait(killCooldown)
                ::NEXT::
            end
        end
        ::CONT::
        task.wait(math.max(0.02, killCooldown))
    end
    killRunning = false
end

-- ===== Teleports =====
local function findNearestCampfire()
    local _,_,hrp = getCharacterParts()
    if not hrp then return nil end
    local rootPos = hrp.Position
    local best, bd = nil, math.huge
    for _, obj in ipairs(workspace:GetDescendants()) do
        if (obj:IsA("Model") or obj:IsA("BasePart")) then
            local n = tostring(obj.Name):lower()
            if n:find("campfire") or n:find("firepit") or n:find("camp") then
                local part = obj:IsA("Model") and (obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")) or obj
                if part then
                    local d = (rootPos - part.Position).Magnitude
                    if d < bd then bd, best = d, part end
                end
            end
        end
    end
    return best
end

local function teleportToCampfire()
    local part = findNearestCampfire()
    if not part then notify("Teleport", "No campfire found!", 3); return end
    local _,_,hrp = getCharacterParts()
    if not hrp then return end
    hrp.CFrame = CFrame.new(part.Position + Vector3.new(0,3,0))
    notify("Teleport", "Teleported to campfire", 2)
end

local function createSafePadAndTeleport()
    local _,_,hrp = getCharacterParts()
    if not hrp then return end
    local base = hrp.Position
    local padY = base.Y + 220
    local pos = Vector3.new(base.X, padY, base.Z)
    local nm = "AxeHubSafePad_" .. player.Name
    if workspace:FindFirstChild(nm) then pcall(function() workspace[nm]:Destroy() end) end
    local pad = Instance.new("Part")
    pad.Name = nm
    pad.Size = Vector3.new(40,1,40)
    pad.Anchored = true
    pad.Position = pos
    pad.Parent = workspace
    hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0))
    notify("Teleport", "Teleported to Safe Place (pad created)", 3)
end

-- ===== UI =====
FarmTab:CreateToggle({
    Name = "Auto Tree Chop",
    CurrentValue = false,
    Callback = function(v)
        autoFarmEnabled = v
        if v then
            notify("Auto Farm", "Started", 2)
            task.spawn(farmWorker)
        else
            notify("Auto Farm", "Stopped", 2)
        end
    end
})
FarmTab:CreateSlider({ Name = "Swing Delay", Range = {0.01,0.5}, Increment = 0.01, CurrentValue = swingDelay, Suffix = "s", Callback = function(val) swingDelay = val end })
FarmTab:CreateSlider({ Name = "Tree Radius", Range = {30,1000}, Increment = 10, CurrentValue = treeSearchRadius, Suffix = "studs", Callback = function(val) treeSearchRadius = val end })

CollectTab:CreateToggle({ Name = "Auto Collect (Drag ‚Üí Store)", CurrentValue = false, Callback = function(v)
    autoCollectEnabled = v
    if v then notify("Auto Collect","Started",2); task.spawn(collectWorker) else notify("Auto Collect","Stopped",2) end
end})
CollectTab:CreateSlider({ Name = "Drag Duration", Range = {0.5,6}, Increment = 0.1, CurrentValue = dragDuration, Suffix = "s", Callback = function(v) dragDuration = v end })
CollectTab:CreateSlider({ Name = "Retries per Log", Range = {1,6}, Increment = 1, CurrentValue = dragRetries, Callback = function(v) dragRetries = v end })
CollectTab:CreateToggle({ Name = "Show Store Pointer", CurrentValue = false, Callback = function(v) pointerShown = v if v then startPointerLoop() else stopPointerLoop() end end })
CollectTab:CreateSlider({ Name = "Vacuum Range", Range = {500,30000}, Increment = 500, CurrentValue = 10000, Suffix = "studs", Callback = function(v) logSearchRadius = v end })
CollectTab:CreateSlider({ Name = "Store Wait Timeout", Range = {2,30}, Increment = 1, CurrentValue = storeWaitTimeout, Suffix = "s", Callback = function(v) storeWaitTimeout = v end })
CollectTab:CreateSlider({ Name = "Click Spam Delay", Range = {0.01,0.2}, Increment = 0.01, CurrentValue = clickSpamDelay, Suffix = "s", Callback = function(v) clickSpamDelay = v end })

CombatTab:CreateToggle({ Name = "Kill Aura (Animals)", CurrentValue = false, Callback = function(v)
    killAuraEnabled = v
    if v then notify("Kill Aura","Enabled",2); task.spawn(killAuraWorker) else notify("Kill Aura","Disabled",2) end
end})
CombatTab:CreateSlider({ Name = "Range", Range = {5,200}, Increment = 1, CurrentValue = killRange, Suffix = "studs", Callback = function(v) killRange = v end })
CombatTab:CreateSlider({ Name = "Attack Cooldown", Range = {0.02,1}, Increment = 0.01, CurrentValue = killCooldown, Suffix = "s", Callback = function(v) killCooldown = v end })
CombatTab:CreateSlider({ Name = "Max Targets", Range = {1,10}, Increment = 1, CurrentValue = killMaxTargets, Callback = function(v) killMaxTargets = v end })

local selectedTeleport = "Campfire"
TeleTab:CreateDropdown({ Name = "Teleport To", Options = { "Campfire", "Safe Place" }, CurrentOption = selectedTeleport, Callback = function(option) selectedTeleport = option end })
TeleTab:CreateButton({ Name = "Teleport", Callback = function()
    if selectedTeleport == "Campfire" then teleportToCampfire() else createSafePadAndTeleport() end
end })

notify("Axe Hub", "Loaded ‚Äî use Farm / Collect / Combat / Teleport tabs", 3)
